<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>transferchain.crypt.crypt API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>transferchain.crypt.crypt</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import hmac
import hashlib
import ed25519
import secrets
import nacl.secret
import nacl.utils
from nacl.public import PrivateKey, Box, PublicKey
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from transferchain.crypt import address


V1 = 0x01
IV_SIZE = 16


def encrypt_asymmetric(sender_key_seed, recipient_key, data):
    &#34;&#34;&#34;
    Encrypt data asymmetrically using sender&#39;s key and recipient&#39;s public key.
    This function encrypts the provided data asymmetrically using the
    sender&#39;s private key seed and the recipient&#39;s public key. It returns the encrypted data.

    Parameters:
        sender_key_seed: Sender&#39;s key seed (str): 
            The sender&#39;s private key seed for encryption.

        recipient_key: Recipient&#39;s public key (str):
            The recipient&#39;s public key for encryption.

        data: Data (bytes):
            The data to be encrypted.

    Returns:
        Encrypted data (bytes): The encrypted data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        message = b&#39;alles gut&#39;
        sender_mnemonics = bip39.create_mnomonics()
        sender = keys.create_keys_with_mnemonic(sender_mnemonics, &#39;p1&#39;)

        recipient_mnemonics = bip39.create_mnomonics()
        recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, &#39;p2&#39;)

        encrypted_data = crypt.encrypt_asymmetric(
            sender[&#39;Seed&#39;], recipient[&#39;Address&#39;], message)
    ```
    &#34;&#34;&#34;
    recipient_pub_key = address.public_key_encrypt_from_address(recipient_key)
    sk = PrivateKey(private_key=bytes.fromhex(sender_key_seed))
    pk = PublicKey(public_key=bytes.fromhex(recipient_pub_key))
    nonce = nacl.utils.random(nacl.secret.SecretBox.NONCE_SIZE)
    box = Box(sk, pk)
    encrypted = box.encrypt(data, nonce)
    return encrypted


def decrypt_asymmetric(sender_address, recipient_seed, encrypted_data):
    &#34;&#34;&#34;
    Decrypt asymmetrically encrypted data using sender&#39;s address and
    recipient&#39;s private key seed.This function decrypts asymmetrically
    encrypted data using the sender&#39;s address and the recipient&#39;s private
    key seed. It returns the decrypted data.

    Exception:
        If the length of the given address is not 64 characters or is empty,
        an Exception is raised, indicating the use of an invalid address.

    Parameters:
        sender_address: Sender&#39;s address (str):
            The sender&#39;s address.

        recipient_seed: Recipient&#39;s private key seed (str):
            The recipient&#39;s private key seed for decryption.

        encrypted_data: Encrypted data (bytes):
            The data to be decrypted.

    Returns:
        Decrypted data (bytes): The decrypted data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        message = b&#39;alles gut&#39;
        sender_mnemonics = bip39.create_mnomonics()
        sender = keys.create_keys_with_mnemonic(sender_mnemonics, &#39;p1&#39;)

        recipient_mnemonics = bip39.create_mnomonics()
        recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, &#39;p2&#39;)

        encrypted_data = crypt.encrypt_asymmetric(
            sender[&#39;Seed&#39;], recipient[&#39;Address&#39;], message)
        decrypted_data = crypt.decrypt_asymmetric(
            sender[&#39;Address&#39;], recipient[&#39;Seed&#39;], encrypted_data)
    ```
    &#34;&#34;&#34;
    sender_pub_key = address.public_key_encrypt_from_address(
        sender_address)
    sk = PrivateKey(private_key=bytes.fromhex(recipient_seed))
    pk = PublicKey(public_key=bytes.fromhex(sender_pub_key))
    box = Box(sk, pk)
    return box.decrypt(encrypted_data[24:], encrypted_data[:24])


def sign(private_key_sign, data):
    &#34;&#34;&#34;
    Sign data using a private signing key.
    This function signs the provided data using the given
    private signing key and returns the digital signature.

    Parameters:
        private_key_sign: Private signing key (str):
            The private key used for signing.

        data: Data (bytes):
            The data to be signed.

    Returns:
        Signature (bytes): The digital signature of the data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        pks = &#39;a0c4e141c6273b9cfd0ffd4ac64110b31189b7051066e92e45ba4534a8a12008baa5f1b8e00a76e8342bb31b105c396d423d9e897df7a290e55fca4ba8249c79&#39; # noqa
        result = crypt.sign(pks, b&#39;alles gut&#39;)
    ```
    &#34;&#34;&#34;
    signing_key = ed25519.SigningKey(bytes.fromhex(private_key_sign))
    return signing_key.sign(data)


def verify_sign(key_address, data, sign):
    &#34;&#34;&#34;
    Verify a digital signature using the public key.
    This function verifies a digital signature using the public key
    associated with the provided address. It returns True if the
    signature is valid, and False otherwise.

    Parameters:
        key_address: Key address (str):
            The address associated with the public key.

        data: Data (bytes):
            The data to be verified.

        sign: Digital signature (bytes):
            The signature to be verified.
    
    Returns:
        Verification result (bool): True if the signature is valid, False otherwise.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt

        mnemonics = bip39.create_mnomonics()
        keys_ = keys.create_keys_with_mnemonic(mnemonics, &#39;p2&#39;)
        data = b&#39;alles gut&#39;
        sign_key = crypt.sign(keys_[&#39;PrivateKeySign&#39;], data)
        result = crypt.verify_sign(keys_[&#39;Address&#39;], data, sign_key)
    ```
    &#34;&#34;&#34;
    try:
        pub_key = address.public_key_sign_from_address(key_address)
        verification_key = ed25519.VerifyingKey(bytes.fromhex(pub_key))
        verification_key.verify(sign, data)
        return True
    except Exception:
        return False


def generate_encrypt_key(size):
    &#34;&#34;&#34;
    Generate a random encryption key of the specified size.
    This function generates a random encryption key of the
    specified size and returns it as a hexadecimal string.

    Parameters:
        size: Key size (int):
            The size of the encryption key.

    Returns:
        Encryption key (str): A randomly generated encryption key of the specified size.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        result = crypt.generate_encrypt_key(10)
    ```
    &#34;&#34;&#34;
    return bytearray(secrets.randbits(8) for _ in range(size)).hex()[:size]


def hash_to_32_bytes(input_str):
    &#34;&#34;&#34;
    Calculate the SHA-256 hash of a string and return the
    result as 32 bytes.This function calculates the SHA-256
    hash of the provided string and returns the result as 32 bytes.

    Parameters:
        input_str: Input string (str):
            The string to be hashed.

    Returns:
        Hash result (bytes): The SHA-256 hash result as 32 bytes.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        crypt.hash_to_32_bytes(&#39;test)
    ```
    &#34;&#34;&#34;
    input_bytes = input_str.encode(&#39;utf-8&#39;)
    sha256 = hashes.Hash(hashes.SHA256(), backend=default_backend())
    sha256.update(input_bytes)
    hash_result = sha256.finalize()
    return hash_result


def encrypt_byte(plaintext, key):
    &#34;&#34;&#34;
    Encrypt a plaintext using AES-GCM with a given key.
    This function encrypts the provided plaintext using the AES-GCM
    encryption algorithm with the specified key and returns the
    encrypted data.

    Parameters:
        plaintext: Plaintext (bytes):
            The data to be encrypted.

        key: Encryption key (str):
            The encryption key used for encryption.

    Returns:
        Encrypted data (bytes): The encrypted data.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        message = b&#39;alles gut&#39;
        key = &#39;secret_key&#39;
        enc_result = crypt.encrypt_byte(message, key)
    ```
    &#34;&#34;&#34;
    new_key = hash_to_32_bytes(key)
    iv = os.urandom(IV_SIZE)
    cipher = Cipher(algorithms.AES(new_key), modes.GCM(iv),
                    backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    return iv + ciphertext + encryptor.tag


def decrypt_aesctr_with_hmac(infile, outfile, aes_key, hmac_key):
    &#34;&#34;&#34;
    Decrypt a file encrypted using AES-CTR mode with HMAC-based
    integrity checks.This function decrypts a file that was
    previously encrypted using AES-CTR mode with HMAC-based
    integrity checks. It reads the encrypted input file, verifies
    the HMAC-based integrity, and writes the decrypted data to
    the output file.

    Exception:
        If the provided input file is invalid, has an invalid version,
        or the HMAC verification fails, an Exception is raised,
        indicating an issue with the input or the file&#39;s integrity.

    Parameters:
        infile: Encrypted input file (file object):
            The file to be decrypted.

        outfile: Decrypted output file (file object):
            The file to store the decrypted data.

        aes_key: AES encryption key (str):
            The key used for AES decryption.

        hmac_key: HMAC key (str):
            The key used for HMAC-based integrity checks.

    Example:
        -
    ```
    from transferchain.crypt import crypt

    input_file_path = &#39;encrypted_file.bin&#39;
    output_file_path = &#39;decrypted_file.txt&#39;

    aes_key = &#39;your_aes_key_here&#39;
    hmac_key = &#39;your_hmac_key_here&#39;

    try:
        with open(input_file_path, &#39;rb&#39;) as encrypted_file, open(output_file_path, &#39;wb&#39;) as decrypted_file:
            crypt.decrypt_aesctr_with_hmac(encrypted_file, decrypted_file, aes_key, hmac_key)
        print(f&#39;Decryption successful. Decrypted file saved to {output_file_path}&#39;)
    except Exception as e:
        print(f&#39;Error: {e}&#39;)
    ```
    &#34;&#34;&#34;
    BUFFER_SIZE = 16 * 1024
    offset = 0

    version = infile.read(1)
    offset += 1
    if int(version) != V1:
        raise Exception(&#39;invalid version&#39;)

    iv = infile.read(IV_SIZE)
    offset += IV_SIZE

    cipher = Cipher(algorithms.AES(aes_key), modes.CTR(iv))
    decryptor = cipher.decryptor()

    hmc = hmac.new(hmac_key, None, hashlib.sha512)
    hmc.update(iv)
    hmac_size = 64

    file_stat = os.stat(infile.name)
    reader_size = file_stat.st_size

    infile_hmac = None
    while True:
        data = infile.read(BUFFER_SIZE)
        if not data:
            break
        limit = len(data)

        if (reader_size &lt; BUFFER_SIZE) \
           or (offset + BUFFER_SIZE &gt;= reader_size):
            limit = len(data) - hmac_size

        d = data[0:limit]
        hmc.update(d)
        result = decryptor.update(d)
        outfile.write(result)
        offset += len(data)

        if offset == reader_size:
            if len(data) &lt; hmac_size:
                raise Exception(&#39;hmac size error&#39;)
            mac = data[-hmac_size:]
            if len(data[len(data) - hmac_size:]) == hmac_size:
                infile_hmac = mac
                break

    if infile_hmac is None:
        raise Exception(&#39;hmac not found&#39;)

    if hmac.compare_digest(hmc.digest(), infile_hmac) is False:
        raise Exception(&#39;invalid hmac&#39;)


def encrypt_aesctr_with_hmac(infile, outfile, aes_key, hmac_key):
    &#34;&#34;&#34;
    Encrypt a file using AES-CTR mode with HMAC-based integrity checks.
    This function encrypts the provided input file using AES-CTR mode
    with HMAC-based integrity checks. It writes the encrypted data to
    the output file and returns the total number of bytes written.
    Note: The function uses a random initialization vector (IV)
    and calculates an HMAC-based digest for data integrity.

    Exception:
        If the provided input file or keys are invalid,
        an Exception is raised, indicating an issue with the inputs.

    Parameters:
        infile: Input file (file object):
            The file to be encrypted.

        outfile: Output file (file object):
            The file to store the encrypted data.

        aes_key: AES encryption key (str):
            The key used for AES encryption.

        hmac_key: HMAC key (str):
            The key used for HMAC-based integrity checks.

    Returns:
        Total bytes written (int): The total number of
        bytes written to the output file.

    Example:
        -
    ```
    from transferchain.crypt import crypt

    input_file_path = &#39;unencrypted_file.txt&#39;
    output_file_path = &#39;encrypted_file.bin&#39;

    aes_key = &#39;your_aes_key_here&#39;
    hmac_key = &#39;your_hmac_key_here&#39;

    try:
        with open(input_file_path, &#39;rb&#39;) as unencrypted_file, open(output_file_path, &#39;wb&#39;) as encrypted_file:
            total_bytes_written = crypt.encrypt_aesctr_with_hmac(unencrypted_file, encrypted_file, aes_key, hmac_key)
        print(f&#39;Encryption successful. Encrypted file saved to {output_file_path}.&#39;)
        print(f&#39;Total bytes written: {total_bytes_written}&#39;)
    except Exception as e:
        print(f&#39;Error: {e}&#39;)
    ```
    &#34;&#34;&#34;
    BUFFER_SIZE = 16 * 1024
    iv = os.urandom(IV_SIZE)

    hmc = hmac.new(hmac_key, None, hashlib.sha512)
    cipher = Cipher(algorithms.AES(aes_key), modes.CTR(iv))
    encryptor = cipher.encryptor()

    hmc.update(iv)
    outfile.write(&#34;{}&#34;.format(V1).encode())
    outfile.write(iv)
    total_count = 0
    while True:
        data = infile.read(BUFFER_SIZE)
        if not data:
            break
        ciphertext = encryptor.update(data)

        hmc.update(ciphertext)
        total_count += outfile.write(ciphertext)
    outfile.write(hmc.digest())
    return total_count


def decrypt_byte(encrypted_data, key):
    &#34;&#34;&#34;
    Decrypt encrypted data using AES-GCM with a given key.
    This function decrypts the provided encrypted data using
    the AES-GCM decryption algorithm with the specified key
    and returns the decrypted data.

    Parameters:
        encrypted_data: Encrypted data (bytes):
            The data to be decrypted.

        key: Decryption key (str):
            The decryption key used for decryption.

    Returns:
        Decrypted data (bytes): The decrypted data.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        message = b&#39;alles gut&#39;
        key = &#39;secret_key&#39;
        enc_result = crypt.encrypt_byte(message, key)
        dec_result = crypt.decrypt_byte(enc_result, key)
    ```
    &#34;&#34;&#34;
    new_key = hash_to_32_bytes(key)
    cipher = Cipher(algorithms.AES(new_key),
                    modes.GCM(encrypted_data[:IV_SIZE],
                              encrypted_data[-IV_SIZE:]),
                    backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(encrypted_data[IV_SIZE:-IV_SIZE]) \
        + decryptor.finalize()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="transferchain.crypt.crypt.decrypt_aesctr_with_hmac"><code class="name flex">
<span>def <span class="ident">decrypt_aesctr_with_hmac</span></span>(<span>infile, outfile, aes_key, hmac_key)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypt a file encrypted using AES-CTR mode with HMAC-based
integrity checks.This function decrypts a file that was
previously encrypted using AES-CTR mode with HMAC-based
integrity checks. It reads the encrypted input file, verifies
the HMAC-based integrity, and writes the decrypted data to
the output file.</p>
<h2 id="exception">Exception</h2>
<p>If the provided input file is invalid, has an invalid version,
or the HMAC verification fails, an Exception is raised,
indicating an issue with the input or the file's integrity.</p>
<h2 id="parameters">Parameters</h2>
<p>infile: Encrypted input file (file object):
The file to be decrypted.</p>
<p>outfile: Decrypted output file (file object):
The file to store the decrypted data.</p>
<p>aes_key: AES encryption key (str):
The key used for AES decryption.</p>
<p>hmac_key: HMAC key (str):
The key used for HMAC-based integrity checks.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>from transferchain.crypt import crypt

input_file_path = 'encrypted_file.bin'
output_file_path = 'decrypted_file.txt'

aes_key = 'your_aes_key_here'
hmac_key = 'your_hmac_key_here'

try:
    with open(input_file_path, 'rb') as encrypted_file, open(output_file_path, 'wb') as decrypted_file:
        crypt.decrypt_aesctr_with_hmac(encrypted_file, decrypted_file, aes_key, hmac_key)
    print(f'Decryption successful. Decrypted file saved to {output_file_path}')
except Exception as e:
    print(f'Error: {e}')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_aesctr_with_hmac(infile, outfile, aes_key, hmac_key):
    &#34;&#34;&#34;
    Decrypt a file encrypted using AES-CTR mode with HMAC-based
    integrity checks.This function decrypts a file that was
    previously encrypted using AES-CTR mode with HMAC-based
    integrity checks. It reads the encrypted input file, verifies
    the HMAC-based integrity, and writes the decrypted data to
    the output file.

    Exception:
        If the provided input file is invalid, has an invalid version,
        or the HMAC verification fails, an Exception is raised,
        indicating an issue with the input or the file&#39;s integrity.

    Parameters:
        infile: Encrypted input file (file object):
            The file to be decrypted.

        outfile: Decrypted output file (file object):
            The file to store the decrypted data.

        aes_key: AES encryption key (str):
            The key used for AES decryption.

        hmac_key: HMAC key (str):
            The key used for HMAC-based integrity checks.

    Example:
        -
    ```
    from transferchain.crypt import crypt

    input_file_path = &#39;encrypted_file.bin&#39;
    output_file_path = &#39;decrypted_file.txt&#39;

    aes_key = &#39;your_aes_key_here&#39;
    hmac_key = &#39;your_hmac_key_here&#39;

    try:
        with open(input_file_path, &#39;rb&#39;) as encrypted_file, open(output_file_path, &#39;wb&#39;) as decrypted_file:
            crypt.decrypt_aesctr_with_hmac(encrypted_file, decrypted_file, aes_key, hmac_key)
        print(f&#39;Decryption successful. Decrypted file saved to {output_file_path}&#39;)
    except Exception as e:
        print(f&#39;Error: {e}&#39;)
    ```
    &#34;&#34;&#34;
    BUFFER_SIZE = 16 * 1024
    offset = 0

    version = infile.read(1)
    offset += 1
    if int(version) != V1:
        raise Exception(&#39;invalid version&#39;)

    iv = infile.read(IV_SIZE)
    offset += IV_SIZE

    cipher = Cipher(algorithms.AES(aes_key), modes.CTR(iv))
    decryptor = cipher.decryptor()

    hmc = hmac.new(hmac_key, None, hashlib.sha512)
    hmc.update(iv)
    hmac_size = 64

    file_stat = os.stat(infile.name)
    reader_size = file_stat.st_size

    infile_hmac = None
    while True:
        data = infile.read(BUFFER_SIZE)
        if not data:
            break
        limit = len(data)

        if (reader_size &lt; BUFFER_SIZE) \
           or (offset + BUFFER_SIZE &gt;= reader_size):
            limit = len(data) - hmac_size

        d = data[0:limit]
        hmc.update(d)
        result = decryptor.update(d)
        outfile.write(result)
        offset += len(data)

        if offset == reader_size:
            if len(data) &lt; hmac_size:
                raise Exception(&#39;hmac size error&#39;)
            mac = data[-hmac_size:]
            if len(data[len(data) - hmac_size:]) == hmac_size:
                infile_hmac = mac
                break

    if infile_hmac is None:
        raise Exception(&#39;hmac not found&#39;)

    if hmac.compare_digest(hmc.digest(), infile_hmac) is False:
        raise Exception(&#39;invalid hmac&#39;)</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.decrypt_asymmetric"><code class="name flex">
<span>def <span class="ident">decrypt_asymmetric</span></span>(<span>sender_address, recipient_seed, encrypted_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypt asymmetrically encrypted data using sender's address and
recipient's private key seed.This function decrypts asymmetrically
encrypted data using the sender's address and the recipient's private
key seed. It returns the decrypted data.</p>
<h2 id="exception">Exception</h2>
<p>If the length of the given address is not 64 characters or is empty,
an Exception is raised, indicating the use of an invalid address.</p>
<h2 id="parameters">Parameters</h2>
<p>sender_address: Sender's address (str):
The sender's address.</p>
<p>recipient_seed: Recipient's private key seed (str):
The recipient's private key seed for decryption.</p>
<p>encrypted_data: Encrypted data (bytes):
The data to be decrypted.</p>
<h2 id="returns">Returns</h2>
<p>Decrypted data (bytes): The decrypted data.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import bip39
    from transferchain.crypt import keys
    from transferchain.crypt import crypt
    message = b'alles gut'
    sender_mnemonics = bip39.create_mnomonics()
    sender = keys.create_keys_with_mnemonic(sender_mnemonics, 'p1')

    recipient_mnemonics = bip39.create_mnomonics()
    recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, 'p2')

    encrypted_data = crypt.encrypt_asymmetric(
        sender['Seed'], recipient['Address'], message)
    decrypted_data = crypt.decrypt_asymmetric(
        sender['Address'], recipient['Seed'], encrypted_data)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_asymmetric(sender_address, recipient_seed, encrypted_data):
    &#34;&#34;&#34;
    Decrypt asymmetrically encrypted data using sender&#39;s address and
    recipient&#39;s private key seed.This function decrypts asymmetrically
    encrypted data using the sender&#39;s address and the recipient&#39;s private
    key seed. It returns the decrypted data.

    Exception:
        If the length of the given address is not 64 characters or is empty,
        an Exception is raised, indicating the use of an invalid address.

    Parameters:
        sender_address: Sender&#39;s address (str):
            The sender&#39;s address.

        recipient_seed: Recipient&#39;s private key seed (str):
            The recipient&#39;s private key seed for decryption.

        encrypted_data: Encrypted data (bytes):
            The data to be decrypted.

    Returns:
        Decrypted data (bytes): The decrypted data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        message = b&#39;alles gut&#39;
        sender_mnemonics = bip39.create_mnomonics()
        sender = keys.create_keys_with_mnemonic(sender_mnemonics, &#39;p1&#39;)

        recipient_mnemonics = bip39.create_mnomonics()
        recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, &#39;p2&#39;)

        encrypted_data = crypt.encrypt_asymmetric(
            sender[&#39;Seed&#39;], recipient[&#39;Address&#39;], message)
        decrypted_data = crypt.decrypt_asymmetric(
            sender[&#39;Address&#39;], recipient[&#39;Seed&#39;], encrypted_data)
    ```
    &#34;&#34;&#34;
    sender_pub_key = address.public_key_encrypt_from_address(
        sender_address)
    sk = PrivateKey(private_key=bytes.fromhex(recipient_seed))
    pk = PublicKey(public_key=bytes.fromhex(sender_pub_key))
    box = Box(sk, pk)
    return box.decrypt(encrypted_data[24:], encrypted_data[:24])</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.decrypt_byte"><code class="name flex">
<span>def <span class="ident">decrypt_byte</span></span>(<span>encrypted_data, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrypt encrypted data using AES-GCM with a given key.
This function decrypts the provided encrypted data using
the AES-GCM decryption algorithm with the specified key
and returns the decrypted data.</p>
<h2 id="parameters">Parameters</h2>
<p>encrypted_data: Encrypted data (bytes):
The data to be decrypted.</p>
<p>key: Decryption key (str):
The decryption key used for decryption.</p>
<h2 id="returns">Returns</h2>
<p>Decrypted data (bytes): The decrypted data.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import crypt

    message = b'alles gut'
    key = 'secret_key'
    enc_result = crypt.encrypt_byte(message, key)
    dec_result = crypt.decrypt_byte(enc_result, key)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrypt_byte(encrypted_data, key):
    &#34;&#34;&#34;
    Decrypt encrypted data using AES-GCM with a given key.
    This function decrypts the provided encrypted data using
    the AES-GCM decryption algorithm with the specified key
    and returns the decrypted data.

    Parameters:
        encrypted_data: Encrypted data (bytes):
            The data to be decrypted.

        key: Decryption key (str):
            The decryption key used for decryption.

    Returns:
        Decrypted data (bytes): The decrypted data.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        message = b&#39;alles gut&#39;
        key = &#39;secret_key&#39;
        enc_result = crypt.encrypt_byte(message, key)
        dec_result = crypt.decrypt_byte(enc_result, key)
    ```
    &#34;&#34;&#34;
    new_key = hash_to_32_bytes(key)
    cipher = Cipher(algorithms.AES(new_key),
                    modes.GCM(encrypted_data[:IV_SIZE],
                              encrypted_data[-IV_SIZE:]),
                    backend=default_backend())
    decryptor = cipher.decryptor()
    return decryptor.update(encrypted_data[IV_SIZE:-IV_SIZE]) \
        + decryptor.finalize()</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.encrypt_aesctr_with_hmac"><code class="name flex">
<span>def <span class="ident">encrypt_aesctr_with_hmac</span></span>(<span>infile, outfile, aes_key, hmac_key)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt a file using AES-CTR mode with HMAC-based integrity checks.
This function encrypts the provided input file using AES-CTR mode
with HMAC-based integrity checks. It writes the encrypted data to
the output file and returns the total number of bytes written.
Note: The function uses a random initialization vector (IV)
and calculates an HMAC-based digest for data integrity.</p>
<h2 id="exception">Exception</h2>
<p>If the provided input file or keys are invalid,
an Exception is raised, indicating an issue with the inputs.</p>
<h2 id="parameters">Parameters</h2>
<p>infile: Input file (file object):
The file to be encrypted.</p>
<p>outfile: Output file (file object):
The file to store the encrypted data.</p>
<p>aes_key: AES encryption key (str):
The key used for AES encryption.</p>
<p>hmac_key: HMAC key (str):
The key used for HMAC-based integrity checks.</p>
<h2 id="returns">Returns</h2>
<p>Total bytes written (int): The total number of
bytes written to the output file.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>from transferchain.crypt import crypt

input_file_path = 'unencrypted_file.txt'
output_file_path = 'encrypted_file.bin'

aes_key = 'your_aes_key_here'
hmac_key = 'your_hmac_key_here'

try:
    with open(input_file_path, 'rb') as unencrypted_file, open(output_file_path, 'wb') as encrypted_file:
        total_bytes_written = crypt.encrypt_aesctr_with_hmac(unencrypted_file, encrypted_file, aes_key, hmac_key)
    print(f'Encryption successful. Encrypted file saved to {output_file_path}.')
    print(f'Total bytes written: {total_bytes_written}')
except Exception as e:
    print(f'Error: {e}')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_aesctr_with_hmac(infile, outfile, aes_key, hmac_key):
    &#34;&#34;&#34;
    Encrypt a file using AES-CTR mode with HMAC-based integrity checks.
    This function encrypts the provided input file using AES-CTR mode
    with HMAC-based integrity checks. It writes the encrypted data to
    the output file and returns the total number of bytes written.
    Note: The function uses a random initialization vector (IV)
    and calculates an HMAC-based digest for data integrity.

    Exception:
        If the provided input file or keys are invalid,
        an Exception is raised, indicating an issue with the inputs.

    Parameters:
        infile: Input file (file object):
            The file to be encrypted.

        outfile: Output file (file object):
            The file to store the encrypted data.

        aes_key: AES encryption key (str):
            The key used for AES encryption.

        hmac_key: HMAC key (str):
            The key used for HMAC-based integrity checks.

    Returns:
        Total bytes written (int): The total number of
        bytes written to the output file.

    Example:
        -
    ```
    from transferchain.crypt import crypt

    input_file_path = &#39;unencrypted_file.txt&#39;
    output_file_path = &#39;encrypted_file.bin&#39;

    aes_key = &#39;your_aes_key_here&#39;
    hmac_key = &#39;your_hmac_key_here&#39;

    try:
        with open(input_file_path, &#39;rb&#39;) as unencrypted_file, open(output_file_path, &#39;wb&#39;) as encrypted_file:
            total_bytes_written = crypt.encrypt_aesctr_with_hmac(unencrypted_file, encrypted_file, aes_key, hmac_key)
        print(f&#39;Encryption successful. Encrypted file saved to {output_file_path}.&#39;)
        print(f&#39;Total bytes written: {total_bytes_written}&#39;)
    except Exception as e:
        print(f&#39;Error: {e}&#39;)
    ```
    &#34;&#34;&#34;
    BUFFER_SIZE = 16 * 1024
    iv = os.urandom(IV_SIZE)

    hmc = hmac.new(hmac_key, None, hashlib.sha512)
    cipher = Cipher(algorithms.AES(aes_key), modes.CTR(iv))
    encryptor = cipher.encryptor()

    hmc.update(iv)
    outfile.write(&#34;{}&#34;.format(V1).encode())
    outfile.write(iv)
    total_count = 0
    while True:
        data = infile.read(BUFFER_SIZE)
        if not data:
            break
        ciphertext = encryptor.update(data)

        hmc.update(ciphertext)
        total_count += outfile.write(ciphertext)
    outfile.write(hmc.digest())
    return total_count</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.encrypt_asymmetric"><code class="name flex">
<span>def <span class="ident">encrypt_asymmetric</span></span>(<span>sender_key_seed, recipient_key, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt data asymmetrically using sender's key and recipient's public key.
This function encrypts the provided data asymmetrically using the
sender's private key seed and the recipient's public key. It returns the encrypted data.</p>
<h2 id="parameters">Parameters</h2>
<p>sender_key_seed: Sender's key seed (str):
The sender's private key seed for encryption.</p>
<p>recipient_key: Recipient's public key (str):
The recipient's public key for encryption.</p>
<p>data: Data (bytes):
The data to be encrypted.</p>
<h2 id="returns">Returns</h2>
<p>Encrypted data (bytes): The encrypted data.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import bip39
    from transferchain.crypt import keys
    from transferchain.crypt import crypt
    message = b'alles gut'
    sender_mnemonics = bip39.create_mnomonics()
    sender = keys.create_keys_with_mnemonic(sender_mnemonics, 'p1')

    recipient_mnemonics = bip39.create_mnomonics()
    recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, 'p2')

    encrypted_data = crypt.encrypt_asymmetric(
        sender['Seed'], recipient['Address'], message)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_asymmetric(sender_key_seed, recipient_key, data):
    &#34;&#34;&#34;
    Encrypt data asymmetrically using sender&#39;s key and recipient&#39;s public key.
    This function encrypts the provided data asymmetrically using the
    sender&#39;s private key seed and the recipient&#39;s public key. It returns the encrypted data.

    Parameters:
        sender_key_seed: Sender&#39;s key seed (str): 
            The sender&#39;s private key seed for encryption.

        recipient_key: Recipient&#39;s public key (str):
            The recipient&#39;s public key for encryption.

        data: Data (bytes):
            The data to be encrypted.

    Returns:
        Encrypted data (bytes): The encrypted data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        message = b&#39;alles gut&#39;
        sender_mnemonics = bip39.create_mnomonics()
        sender = keys.create_keys_with_mnemonic(sender_mnemonics, &#39;p1&#39;)

        recipient_mnemonics = bip39.create_mnomonics()
        recipient = keys.create_keys_with_mnemonic(recipient_mnemonics, &#39;p2&#39;)

        encrypted_data = crypt.encrypt_asymmetric(
            sender[&#39;Seed&#39;], recipient[&#39;Address&#39;], message)
    ```
    &#34;&#34;&#34;
    recipient_pub_key = address.public_key_encrypt_from_address(recipient_key)
    sk = PrivateKey(private_key=bytes.fromhex(sender_key_seed))
    pk = PublicKey(public_key=bytes.fromhex(recipient_pub_key))
    nonce = nacl.utils.random(nacl.secret.SecretBox.NONCE_SIZE)
    box = Box(sk, pk)
    encrypted = box.encrypt(data, nonce)
    return encrypted</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.encrypt_byte"><code class="name flex">
<span>def <span class="ident">encrypt_byte</span></span>(<span>plaintext, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Encrypt a plaintext using AES-GCM with a given key.
This function encrypts the provided plaintext using the AES-GCM
encryption algorithm with the specified key and returns the
encrypted data.</p>
<h2 id="parameters">Parameters</h2>
<p>plaintext: Plaintext (bytes):
The data to be encrypted.</p>
<p>key: Encryption key (str):
The encryption key used for encryption.</p>
<h2 id="returns">Returns</h2>
<p>Encrypted data (bytes): The encrypted data.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import crypt

    message = b'alles gut'
    key = 'secret_key'
    enc_result = crypt.encrypt_byte(message, key)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encrypt_byte(plaintext, key):
    &#34;&#34;&#34;
    Encrypt a plaintext using AES-GCM with a given key.
    This function encrypts the provided plaintext using the AES-GCM
    encryption algorithm with the specified key and returns the
    encrypted data.

    Parameters:
        plaintext: Plaintext (bytes):
            The data to be encrypted.

        key: Encryption key (str):
            The encryption key used for encryption.

    Returns:
        Encrypted data (bytes): The encrypted data.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        message = b&#39;alles gut&#39;
        key = &#39;secret_key&#39;
        enc_result = crypt.encrypt_byte(message, key)
    ```
    &#34;&#34;&#34;
    new_key = hash_to_32_bytes(key)
    iv = os.urandom(IV_SIZE)
    cipher = Cipher(algorithms.AES(new_key), modes.GCM(iv),
                    backend=default_backend())
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    return iv + ciphertext + encryptor.tag</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.generate_encrypt_key"><code class="name flex">
<span>def <span class="ident">generate_encrypt_key</span></span>(<span>size)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a random encryption key of the specified size.
This function generates a random encryption key of the
specified size and returns it as a hexadecimal string.</p>
<h2 id="parameters">Parameters</h2>
<p>size: Key size (int):
The size of the encryption key.</p>
<h2 id="returns">Returns</h2>
<p>Encryption key (str): A randomly generated encryption key of the specified size.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import crypt

    result = crypt.generate_encrypt_key(10)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_encrypt_key(size):
    &#34;&#34;&#34;
    Generate a random encryption key of the specified size.
    This function generates a random encryption key of the
    specified size and returns it as a hexadecimal string.

    Parameters:
        size: Key size (int):
            The size of the encryption key.

    Returns:
        Encryption key (str): A randomly generated encryption key of the specified size.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        result = crypt.generate_encrypt_key(10)
    ```
    &#34;&#34;&#34;
    return bytearray(secrets.randbits(8) for _ in range(size)).hex()[:size]</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.hash_to_32_bytes"><code class="name flex">
<span>def <span class="ident">hash_to_32_bytes</span></span>(<span>input_str)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the SHA-256 hash of a string and return the
result as 32 bytes.This function calculates the SHA-256
hash of the provided string and returns the result as 32 bytes.</p>
<h2 id="parameters">Parameters</h2>
<p>input_str: Input string (str):
The string to be hashed.</p>
<h2 id="returns">Returns</h2>
<p>Hash result (bytes): The SHA-256 hash result as 32 bytes.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import crypt

    crypt.hash_to_32_bytes('test)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_to_32_bytes(input_str):
    &#34;&#34;&#34;
    Calculate the SHA-256 hash of a string and return the
    result as 32 bytes.This function calculates the SHA-256
    hash of the provided string and returns the result as 32 bytes.

    Parameters:
        input_str: Input string (str):
            The string to be hashed.

    Returns:
        Hash result (bytes): The SHA-256 hash result as 32 bytes.

    Example:
        -
    ```
        from transferchain.crypt import crypt

        crypt.hash_to_32_bytes(&#39;test)
    ```
    &#34;&#34;&#34;
    input_bytes = input_str.encode(&#39;utf-8&#39;)
    sha256 = hashes.Hash(hashes.SHA256(), backend=default_backend())
    sha256.update(input_bytes)
    hash_result = sha256.finalize()
    return hash_result</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>private_key_sign, data)</span>
</code></dt>
<dd>
<div class="desc"><p>Sign data using a private signing key.
This function signs the provided data using the given
private signing key and returns the digital signature.</p>
<h2 id="parameters">Parameters</h2>
<p>private_key_sign: Private signing key (str):
The private key used for signing.</p>
<p>data: Data (bytes):
The data to be signed.</p>
<h2 id="returns">Returns</h2>
<p>Signature (bytes): The digital signature of the data.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import bip39
    from transferchain.crypt import keys
    from transferchain.crypt import crypt
    pks = 'a0c4e141c6273b9cfd0ffd4ac64110b31189b7051066e92e45ba4534a8a12008baa5f1b8e00a76e8342bb31b105c396d423d9e897df7a290e55fca4ba8249c79' # noqa
    result = crypt.sign(pks, b'alles gut')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(private_key_sign, data):
    &#34;&#34;&#34;
    Sign data using a private signing key.
    This function signs the provided data using the given
    private signing key and returns the digital signature.

    Parameters:
        private_key_sign: Private signing key (str):
            The private key used for signing.

        data: Data (bytes):
            The data to be signed.

    Returns:
        Signature (bytes): The digital signature of the data.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt
        pks = &#39;a0c4e141c6273b9cfd0ffd4ac64110b31189b7051066e92e45ba4534a8a12008baa5f1b8e00a76e8342bb31b105c396d423d9e897df7a290e55fca4ba8249c79&#39; # noqa
        result = crypt.sign(pks, b&#39;alles gut&#39;)
    ```
    &#34;&#34;&#34;
    signing_key = ed25519.SigningKey(bytes.fromhex(private_key_sign))
    return signing_key.sign(data)</code></pre>
</details>
</dd>
<dt id="transferchain.crypt.crypt.verify_sign"><code class="name flex">
<span>def <span class="ident">verify_sign</span></span>(<span>key_address, data, sign)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a digital signature using the public key.
This function verifies a digital signature using the public key
associated with the provided address. It returns True if the
signature is valid, and False otherwise.</p>
<h2 id="parameters">Parameters</h2>
<p>key_address: Key address (str):
The address associated with the public key.</p>
<p>data: Data (bytes):
The data to be verified.</p>
<p>sign: Digital signature (bytes):
The signature to be verified.</p>
<h2 id="returns">Returns</h2>
<p>Verification result (bool): True if the signature is valid, False otherwise.</p>
<h2 id="example">Example</h2>
<p>-</p>
<pre><code>    from transferchain.crypt import bip39
    from transferchain.crypt import keys
    from transferchain.crypt import crypt

    mnemonics = bip39.create_mnomonics()
    keys_ = keys.create_keys_with_mnemonic(mnemonics, 'p2')
    data = b'alles gut'
    sign_key = crypt.sign(keys_['PrivateKeySign'], data)
    result = crypt.verify_sign(keys_['Address'], data, sign_key)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_sign(key_address, data, sign):
    &#34;&#34;&#34;
    Verify a digital signature using the public key.
    This function verifies a digital signature using the public key
    associated with the provided address. It returns True if the
    signature is valid, and False otherwise.

    Parameters:
        key_address: Key address (str):
            The address associated with the public key.

        data: Data (bytes):
            The data to be verified.

        sign: Digital signature (bytes):
            The signature to be verified.
    
    Returns:
        Verification result (bool): True if the signature is valid, False otherwise.

    Example:
        -
    ```
        from transferchain.crypt import bip39
        from transferchain.crypt import keys
        from transferchain.crypt import crypt

        mnemonics = bip39.create_mnomonics()
        keys_ = keys.create_keys_with_mnemonic(mnemonics, &#39;p2&#39;)
        data = b&#39;alles gut&#39;
        sign_key = crypt.sign(keys_[&#39;PrivateKeySign&#39;], data)
        result = crypt.verify_sign(keys_[&#39;Address&#39;], data, sign_key)
    ```
    &#34;&#34;&#34;
    try:
        pub_key = address.public_key_sign_from_address(key_address)
        verification_key = ed25519.VerifyingKey(bytes.fromhex(pub_key))
        verification_key.verify(sign, data)
        return True
    except Exception:
        return False</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="transferchain.crypt" href="index.html">transferchain.crypt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="transferchain.crypt.crypt.decrypt_aesctr_with_hmac" href="#transferchain.crypt.crypt.decrypt_aesctr_with_hmac">decrypt_aesctr_with_hmac</a></code></li>
<li><code><a title="transferchain.crypt.crypt.decrypt_asymmetric" href="#transferchain.crypt.crypt.decrypt_asymmetric">decrypt_asymmetric</a></code></li>
<li><code><a title="transferchain.crypt.crypt.decrypt_byte" href="#transferchain.crypt.crypt.decrypt_byte">decrypt_byte</a></code></li>
<li><code><a title="transferchain.crypt.crypt.encrypt_aesctr_with_hmac" href="#transferchain.crypt.crypt.encrypt_aesctr_with_hmac">encrypt_aesctr_with_hmac</a></code></li>
<li><code><a title="transferchain.crypt.crypt.encrypt_asymmetric" href="#transferchain.crypt.crypt.encrypt_asymmetric">encrypt_asymmetric</a></code></li>
<li><code><a title="transferchain.crypt.crypt.encrypt_byte" href="#transferchain.crypt.crypt.encrypt_byte">encrypt_byte</a></code></li>
<li><code><a title="transferchain.crypt.crypt.generate_encrypt_key" href="#transferchain.crypt.crypt.generate_encrypt_key">generate_encrypt_key</a></code></li>
<li><code><a title="transferchain.crypt.crypt.hash_to_32_bytes" href="#transferchain.crypt.crypt.hash_to_32_bytes">hash_to_32_bytes</a></code></li>
<li><code><a title="transferchain.crypt.crypt.sign" href="#transferchain.crypt.crypt.sign">sign</a></code></li>
<li><code><a title="transferchain.crypt.crypt.verify_sign" href="#transferchain.crypt.crypt.verify_sign">verify_sign</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>